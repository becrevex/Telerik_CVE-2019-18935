# Programmer: Brent 'becrevex' Chambers
# Date: May 24, 2020
# Filename: telerik_rce_scan.py
# Description:  TelerikUI CVE-2019-18935 vulnerability scanner

import re
import csv
import requests
import argparse
import random
import time
import ipaddress
import traceback
import datetime
from queue import Queue 
import threading
requests.packages.urllib3.disable_warnings() # disable lame SSL warnings

help_example = "EXAMPLE: telerik_rce_check -t 104.28.18.139"
parser = argparse.ArgumentParser(description='Telerik RAU RCE Detection'+'\n\n'+ help_example, formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('-r', '--range')
parser.add_argument('-t', '--target')
#parser.add_argument('-f', '--fastscan', help='Multi-threaded implementation for increased performance')
parser.add_argument('-iL', '--inputfile', help='Specify a filename for bulk target scanning.')
#parser.add_argument('-oW', '--outputweb', help='Creates output file of discovered web servers.')
#parser.add_argument('-search', action='store_true', help='Searches IPv4 space for vulnerable hosts. (2 Second delay)')
args = parser.parse_args()

vuln_checks = ['/Telerik.Web.UI.WebResource.axd?type=rau',
				'/aspnet-ajax/Telerik.Web.UI.WebResource.axd?type=rau']


web_discovery = {}		
q = Queue()

def print_vuln_table():
	print(" [!] LIKELY VULNERABLE")
	print("""
	Risk: HIGH               CVE: CVE-2019-18935             CWE: CWE-913
	---------------------------------------------------------------------
	Telerik UI for ASP.NET AJAX through 2019.3.1023 contains a 
	.NET deserialization RCE vulnerability in the RadAsyncUpload function.

	-- 	As of 2020.1.114, a default setting prevents the exploit. 
	--  In 2019.3.1023, but not earlier versions, a non-default 
	--  setting can prevent exploitation.

	-- This is exploitable when the encryption keys are known due 
	-- to the presence of CVE-2017-11317 or CVE-2017-11357.  
	-- Exploitation can result in remote code execution. 
	""")


def execution_header():
	print("TelerikUI RCE Scan ( github.com/becrevex/Telerik_CVE-2019-18935 ) \n")
	print(help_example)
	stamp = datetime.datetime.now()
	print("Starting CVE-2019-18935 (Telerik RCE) scan at " + str(stamp))
	print()
	

def is_valid_ip(ip):
	"""Checks if IP is valid"""
	test = re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$",ip)
	if test:
		return True
	else:
		return False
		

def is_valid_hostname(hostname):
    """Checks if hostname is valid for scanning """
    if hostname[-1] == ".":
        # strip exactly one dot from the right, if present
        hostname = hostname[:-1]
    if len(hostname) > 253:
        return False
    labels = hostname.split(".")
    # the TLD must be not all-numeric
    if re.match(r"[0-9]+$", labels[-1]):
        return False
    allowed = re.compile(r"(?!-)[a-z0-9-]{1,63}(?<!-)$", re.IGNORECASE)
    return all(allowed.match(label) for label in labels)


def random_IP():
	oct1 = random.randint(1,254)
	oct2 = random.randint(1,254)
	oct3 = random.randint(1,254)
	oct4 = random.randint(1,254)
	ip = str(oct1) + "." + str(oct2) + "." + str(oct3) + "." + str(oct4)
	return ip

def search():    
	while 1:
		check_vuln(random_IP())
		time.sleep(2)
		
def range_scan(netrange):
	#print("Running range scan...")
	for i in [str(ip) for ip in ipaddress.IPv4Network(netrange)]:
		check_vuln_bulk(i)
	write_web_to_file("web_discovery.csv")

def check_version_vuln(version):
	print(version)
	year = version.split(".")[0]
	sub = version.split(".")[1]
	sub2 = version.split(".")[2]
	if (int(year) < 2020):
		return True
	elif (int(year) >= 2020 and int(sub) >= 3 and int(sub2) >= 1023):
		print("Patched.  NOT VULNERABLE")
		return False
	elif (int(year) <= 2020) and (int(sub) <= 2):
		return True
	else:
		print("Patched.  NOT VULNERABLE")
		return False
		
def check_for_patch(version):
	print(version)
	year = version.split(".")[0]
	sub = version.split(".")[1]
	sub2 = version.split(".")[2]
	if (int(year) >= 2020 and int(sub) >= 3 and int(sub2) >= 1023):
		print(version.split("."))
		return True			# found patched version
	else:
		return False					
	
def read_from_file(filepath):
	with open(filepath) as fd:
		targets = fd.read().splitlines()
	return targets
	
def check_source_for_ver(target):
	print("Checking target for vulnerable versions...")
	s = '20[0-9]{2}(?:\.[0-9]*)+'
	source = requests.get("https://"+target, verify=False)
	result = re.search(s, source.text)
	results = re.findall(s, source.text)
	#print(results)
	status = False
	#print(len(results))
	print("Identified version matches for [" + target + "]: ")
	for i in list(dict.fromkeys(results)):
		if (len(i.split(".")) >= 3):
			if check_version_vuln(i):
				status = True
			#elif check_for_patch(i):
			#	status = False # if it comes back as patched, return to call and label the version not vulnerable				
	return status
	
def write_web_to_file():
	stamp = datetime.datetime.now()
	filename = str(stamp)
	filen = filename.replace(" ", "_")
	filena = filen.replace(":", "_")
	w = csv.writer(open(filena+".csv", "w", newline=''))
	for key, val in web_discovery.items():
		w.writerow([key, val])
	print("Results file saved as: ", filena+".csv")
	
def check_vuln(target):
	status = ""
	string_text = "RadAsyncUpload handler is registered succesfully"
	print("Checking: " + target)
	for uri in vuln_checks:
		try:
			r = requests.get('https://'+ target + uri, verify=False)
			status = r.status_code
			if status == 200:
				# if r.body contains "RadAsyncUpload handler is registered succesfully"
				print("Server found ["+target+"]: ", r.headers['Server'])
				if string_text in r.text:
					print("[!] RAU Module Found [ " + target + uri + " ]!")
					if (check_source_for_ver(target)):
						print_vuln_table()
						return
				return
			else:
				pass
				#print("Telerik RAU Module not found on " + target + ":Status " + str(status))
		except Exception as ex:
			print(ex)
			#traceback.print_exc()			 commenting out for prezo
			
def threader():
	while True:
		worker = q.get()
		check_vuln_bulk(worker)
		q.task_done()
	print("Done.")
	stamp = datetime.datetime.now()
	print("\nPlatform identification scan completed at " + str(stamp))

		
def threaded_range_scanner(netrange):
	for x in range(10):
		t = threading.Thread(target = threader)
		t.daemon = True
		t.start()
		
	for worker in [str(ip) for ip in ipaddress.IPv4Network(netrange)]:
		q.put(worker)
		
	q.join()


def check_vuln_bulk(target):
	status = ""
	string_text = "RadAsyncUpload handler is registered succesfully"
	print("Checking: " + target)
	servertype = ""
	for uri in vuln_checks:
		try:
			r = requests.get('https://'+ target + uri, timeout=0.9, verify=False)
			status = r.status_code
			#print("[+] Service Found: " + target)
			servertype = r.headers['Server']
			if status == 200:
				# if r.body contains "RadAsyncUpload handler is registered succesfully"
				print("Server found ["+target+"]: ", r.headers['Server'])
				if string_text in r.text:
					print("[!] RAU Module Found [ " + target + uri + " ]!")
					if (check_source_for_ver(target)):
						print_vuln_table()
						return
				return
			else:
				pass
				#print("Server: ", r.headers['Server'])
				#print("    [+] Telerik RAU Module not found on " + target + ".   Status (" + str(status) + ")")
		except Exception as ex:
			pass
	if servertype != "":
		web_discovery[target]=servertype
		print("    [+] Server: ", servertype)


def assess_target(target):
	status = ""
	string_text = "RadAsyncUpload handler is registered succesfully"
	#print("Checking: " + target)
	servertype = ""
	for uri in vuln_checks:
		try:
			r = requests.get('https://'+ target + uri, timeout=0.9, verify=False)
			status = r.status_code
			#print("[+] Service Found: " + target)
			servertype = r.headers['Server']
			if status == 200:
				# if r.body contains "RadAsyncUpload handler is registered succesfully"
				print("Server ["+target+"]: ", r.headers['Server'])
				if string_text in r.text:
					print("[!] RAU Module Found [ " + target + uri + " ]!")
					if (check_source_for_ver(target)):
						print_vuln_table()
						return
				return
			else:
				pass
				#print("Server: ", r.headers['Server'])
				#print("    [+] Telerik RAU Module not found on " + target + ".   Status (" + str(status) + ")")
		except Exception as ex:
			pass


if __name__=='__main__':
	if args.inputfile:
		execution_header()
		targets = read_from_file(args.inputfile)
		for host in targets:
			threaded_range_scanner(host)
		#write_web_to_file()


	elif args.target:
		execution_header()
		if is_valid_ip(args.target):
			check_vuln(args.target)

		elif is_valid_hostname(args.target):
			check_vuln(args.target)

	#elif args.range:
	#	execution_header()
	#	range_scan(args.range)
		
	elif args.range:
		execution_header()
		threaded_range_scanner(args.range)
		#write_web_to_file()
			
	else:
		parser.print_help()
else:
	parser.print_help()	
		


